import { SearchResult, FindOptions, PdfSearcherOptions } from "./types";
import PdfReportPlugin from "../plugin";
//@ts-ignore
import { PluginModel, SearchFeature } from "@grapecity/viewer-core";
import { IPdfSearcher } from "./IPdfSearcher";
import { IGcTextRect } from "../Models/GcMeasurementTypes";
import { ICustomHighlight } from "../HighlightManager/types";
export declare class GcPdfSearcher implements IPdfSearcher {
    readonly _plugin: PdfReportPlugin;
    private _cancellation?;
    private _extractTextPromises;
    private _normalizedQuery;
    private _pageContents;
    private _pageContentsEndings;
    _pageTextContents: any[];
    _pageMatches: number[][];
    _pageMatchesLength: number[][];
    private _pageAcroFormResults;
    allResults: SearchResult[];
    private _pagesCount;
    private _pdfDocument;
    private _rawQuery;
    private _state;
    private _totalResultsCount;
    private _totalResultsCountPromise;
    private _firstSearchResult?;
    private _selectedSearchResult?;
    constructor(_plugin: PdfReportPlugin);
    get viewer(): import("..").GcPdfViewer;
    fetchPageContent(pageIndex: number): Promise<string>;
    fetchPageTextRects(pageIndex: number): Promise<{
        items: IGcTextRect[];
        styles: any[];
    }>;
    fetchPageContentLineEndings(pageIndex: number): Promise<{
        [x: number]: boolean;
    }>;
    createHighlightFromTextSegment(pageIndex: number, startCharIndex: number, endCharIndex: number, args: {
        color?: string;
        borderColor?: string;
        borderWidth?: number;
        paintHandler?: any;
    }): Promise<ICustomHighlight | null>;
    toggle(forceExpand?: boolean, replaceMode?: boolean): void;
    close(): void;
    updateUIState(state: any, previous: any, matchesCount: any): void;
    nextSearchResult(result: SearchResult, cancellation: any): Promise<SearchResult>;
    isResultSelected(result: SearchResult): boolean;
    get state(): PdfSearcherOptions;
    get highlightAll(): boolean;
    set highlightAll(checked: boolean);
    get findController(): any;
    applyHighlight(): void;
    resetResults(): void;
    updateAllPages(): void;
    get selectedSearchResult(): SearchResult | undefined;
    get selectedSearchResultIndex(): number;
    get totalResultsCount(): number;
    get totalResultsCountPromise(): Promise<number> | null;
//@ts-ignore
    search(options: FindOptions): AsyncIterableIterator<SearchResult>;
    highlight(searchResult: SearchFeature.SearchResult | null, pageIndex?: number): Promise<void>;
    cancel(): void;
    _initialize(): void;
    get _query(): string;
    _extractText(): void;
    _reset(): void;
    _prepareMatches(matchesWithLength: any, matches: any, matchesLength: any): void;
    _isEntireWord(content: any, lineEndings: {
        [x: number]: boolean;
    }, startIdx: any, length: any): boolean;
    _isStartsWith(content: any, lineEndings: {
        [x: number]: boolean;
    }, startIdx: any, _length: any): boolean;
    _isEndsWith(content: any, lineEndings: {
        [x: number]: boolean;
    }, startIdx: any, length: any): boolean;
    _findPhraseMathIndex(pageContent: string, query: string, startIndex: number, lineEndings: {
        [x: number]: boolean;
    }): {
        matchIdx: number;
        queryLen: number;
    } | null;
    _calculatePhraseMatch(query: string, pageContentsEndings: {
        [x: number]: boolean;
    }, pageContent: string, entireWord: boolean, startsWith: boolean, endsWith: boolean, wildcards: boolean): {
        matches: number[];
        matchesLength: number[];
    };
    findLineEndIndex(startIndex: number, pageContent: string, lineEndings: {
        [x: number]: boolean;
    }): number;
    _calculateWordMatch(query: string, pageContentsEndings: {
        [x: number]: boolean;
    }, pageContent: any, entireWord: any, startsWith: any, endsWith: any, wildcards: any): {
        matches: number[];
        matchesLength: number[];
    };
    _calculateMatch(pageContent: string, pageContentsEndings: {
        [x: number]: boolean;
    }): {
        matches: number[];
        matchesLength: number[];
    };
    private handleProximitySearch;
    private validateProximityConditions;
    private collectMatchesForOrder;
    getContentSnippet(startInd: number, endInd: number, pageContent: string, pageContentsEndings: {
        [x: number]: boolean;
    }, fillLineEndingsWithSpaces?: boolean): string;
    _countWordsBetweenTerms(startInd: number, endInd: number, pageContent: string, pageContentsEndings: {
        [x: number]: boolean;
    }): number;
    private deduplicateMatches;
    _proximityCheckAllWordsInResults(queryArray: RegExpMatchArray, matchIndicesToKeep: {
        matchIndex: number;
        matchLength: number;
    }[], pageContent: string): boolean;
    _findMathIndexByQuery(pageContent: string, mathes: number[], mathesLength: number[], subquery: string, startIndex: number): {
        mathIndex: number;
        mathLength: number;
    };
    renderHighlightPage(page: PluginModel.IPageData, results: SearchFeature.SearchResult[]): PluginModel.PageView;
}
